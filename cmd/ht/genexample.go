// Copyright 2017 Volker Dobler.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strings"
)

// Example should match cmd/ht.Example
type Example struct {
	Name        string     // Name like "Test" or "Test.SQL.Update"
	Description string     // Short description
	Data        string     // The real example
	Sub         []*Example // Subtopics below this Example
}

func main() {
	root := loadExamples()

	buf := &bytes.Buffer{}
	buf.WriteString(`// generated by go run genexample.go; DO NOT EDIT

package main

var RootExample = `)

	dump(buf, root, false)
	buf.WriteString("\n")

	b, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("cannot format data: %s\n%s", err, buf.Bytes())
	}

	err = ioutil.WriteFile("exampledata.go", b, 0644)
	if err != nil {
		log.Fatal(err)
	}
}

func dump(buf *bytes.Buffer, ex *Example, comma bool) {
	buf.WriteString("&Example{\n")
	fmt.Fprintf(buf, "  Name: %q,\n", ex.Name)
	fmt.Fprintf(buf, "  Description: %q,\n", ex.Description)
	fmt.Fprintf(buf, "  Data: %s,\n", quote(ex.Data))
	if len(ex.Sub) > 0 {
		fmt.Fprintf(buf, "  Sub: []*Example{\n")
		for _, sub := range ex.Sub {
			dump(buf, sub, true)
		}
		fmt.Fprintf(buf, "  },\n")
	}
	buf.WriteString("}")
	if comma {
		fmt.Fprintf(buf, ",")
	}
}

func quote(s string) string {
	parts := strings.Split(s, "`")
	return "`" + strings.Join(parts, "` + \"`\" +\n`") + "`"
}

func loadExamples() *Example {
	f, err := os.Open("./examples")
	if err != nil {
		panic(err)
	}
	names, err := f.Readdirnames(-1)
	if err != nil {
		panic(err)
	}

	sort.Strings(names)
	root := &Example{
		Sub: subexamples(names, "", 0),
	}
	return root
}

func isNotExample(filename string) bool {
	if strings.HasSuffix(filename, "~") {
		return true // Backup files from Emacs
	}
	if filename[0] >= 'a' && filename[0] <= 'z' {
		return true // lowercase names are simple support files
	}
	return false
}

func subexamples(names []string, prefix string, level int) []*Example {
	var subs []*Example
	for _, name := range names {
		if !strings.HasPrefix(name, prefix) ||
			strings.Count(name, ".") != level ||
			isNotExample(name) {
			continue
		}

		bdata, err := ioutil.ReadFile("./examples/" + name)
		if err != nil {
			panic(err)
		}
		bdata = bytes.TrimRight(bdata, " \n\t")

		example := Example{
			Name: name,
			Data: string(bdata),
			Sub:  subexamples(names, name+".", level+1),
		}
		eol := strings.Index(example.Data, "\n")
		example.Description = example.Data[3:eol]

		subs = append(subs, &example)
	}

	return subs
}
