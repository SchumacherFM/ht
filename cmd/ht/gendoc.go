// Copyright 2016 Volker Dobler.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os/exec"
	"strings"

	"github.com/vdobler/ht/ht"
)

func allTypes() []string {
	t := []string{}

	ftypes := []string{
		"Test", "Request", "Cookie", "Execution",
		"CheckList", "ExtractorMap", "Condition",
	}
	for _, name := range ftypes {
		t = append(t, "github.com/vdobler/ht/ht."+name)
	}

	for name := range ht.CheckRegistry {
		t = append(t, "github.com/vdobler/ht/ht."+name)
	}

	for name := range ht.ExtractorRegistry {
		t = append(t, "github.com/vdobler/ht/ht."+name)
	}

	rtypes := []string{
		"RawTest", "RawSuite", "RawElement", "RawScenario",
		"RawLoadTest",
	}
	for _, name := range rtypes {
		t = append(t, "github.com/vdobler/ht/suite."+name)
	}

	return t
}

func main() {
	err := generate()
	if err != nil {
		log.Fatal(err)
	}
}

func generate() error {
	buf := new(bytes.Buffer)
	buf.WriteString(`// generated by go run gendoc.go; DO NOT EDIT

package main

var typeDoc = map[string]string {
`)

	for _, t := range allTypes() {
		doc, err := documentation(t)
		if err != nil {
			return fmt.Errorf("cannot generate doc for %s: %s", t, err)
		}

		name := strings.ToLower(t[strings.LastIndex(t, ".")+1:])

		N := len(doc)
		_, err = fmt.Fprintf(buf, "%q: %q + \n", name, doc[0]+"\n")
		if err != nil {
			return err
		}
		for _, line := range doc[1 : N-1] {
			_, err = fmt.Fprintf(buf, "    %q +\n", line+"\n")
			if err != nil {
				return err
			}
		}
		_, err = fmt.Fprintf(buf, "    %q,\n", doc[N-1])
		if err != nil {
			return err
		}
	}

	buf.WriteString("}\n")

	b, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("cannot format data: %s\n%s", err, buf.Bytes())
	}

	return ioutil.WriteFile("docdata.go", b, 0644)
}

func documentation(typ string) ([]string, error) {
	gocmd := exec.Command("go", "doc", typ)
	output, err := gocmd.CombinedOutput()
	if err != nil {
		return nil, err
	}

	output = bytes.Replace(output,
		[]byte("`json:\",omitempty\"`"), []byte(""),
		-1)
	output = bytes.Replace(output,
		[]byte("`json:\"-\"`"), []byte(""),
		-1)

	// This is inefficient, but okay direktly befor a os.Exit.
	buf := []string{}
	for _, line := range bytes.Split(output, []byte("\n")) {
		if bytes.HasPrefix(line, []byte("func ")) {
			continue
		}
		buf = append(buf, string(line))
	}
	for buf[len(buf)-1] == "" {
		buf = buf[:len(buf)-1]
	}
	return buf, nil
}
