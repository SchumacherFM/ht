// generated by go run genexample.go; DO NOT EDIT

package main

var RootExample = &Example{
	Name:        "",
	Description: "",
	Data:        ``,
	Sub: []*Example{
		&Example{
			Name:        "Mixin",
			Description: "Mixins allow to add stuff to a Test",
			Data: `// Mixins allow to add stuff to a Test
{
    // A Mixin is technically a Test, it has the same fields. But it is
    // not executed directly but mixed into a real Tests to add common
    // stuff like headers or even Checks like this:
    // {
    //     Name: "Some Test"
    //     Mixin: [ "Mixin" ]  // Load this mixin here.
    //     Request: { URL: "http://example.org" }
    // }
    // Mixins are merged into the test through complicated rules.
    // Consult https://godoc.org/github.com/vdobler/ht/ht#Merge for details.

    Name: "German-Chrome"
    Description: "Some headers of a German Chrome Browser"
    Request: {
        Header: {
            User-Agent: "Chrome/41.0.2272.101"
            Accept: "text/html,application/xml;q=0.9,image/webp,*/*;q=0.8"
            Accept-Language: "de-DE,de;q=0.8,en-US;q=0.6,en;q=0.4,fr;q=0.2"
            Accept-Encoding: "gzip, deflate, sdch"
        }
    }
}`,
			Sub: []*Example{
				&Example{
					Name:        "Mixin.Checks",
					Description: "A Mixin consisting for adding Checks to a Test",
					Data: `// A Mixin consisting for adding Checks to a Test
{
    Name: "Standard Checks on HTML pages"
    // Such a mixin makes it easy to have a default set of checks every
    // HTML document is supposed to fulfill.
    Checks: [
        {Check: "StatusCode", Expect: 200}
        {Check: "ResponseTime", Lower: "700ms"}
        {Check: "ContentType", Is: "text/html"}
        {Check: "UTF8Encoded"}
        {Check: "ValidHTML"}
    ]
}`,
				}},
		}, &Example{
			Name:        "Mock",
			Description: "Providing Mock Responses",
			Data: `// Providing Mock Responses
// Mocks have two uses: They can be run as independent, long-running  mock
// services via ` + "`" +
				`ht mock <mock>` + "`" +
				` or be part of a single Test execution inside
// a Suite. The following shows general parts common to both types of mocks.
{
    Name: "Mock Service for Foobar" // Give it a short, informative name.
    Description: '''
        This description is not used but it is nice to
        provide same background information on this mock.
    '''

    // This mock is invoked only for GET requests.
    Method: "GET"

    // This mock is invoked if schema (http), hostname (localhost:8080) and
    // patch (/greet/something) match the request.
    // The Variable NAME is extracted from the path automatically.
    URL: "http://localhost:8880/greet/{NAME}"
    
    // If method and URL trigger this mock, then send the following response.
    // Only the shown three fields are available and should be self explaining.
    Response: {
        StatusCode: 200
        Header: {
            "Content-Type": "text/plain"
        }
        Body: "{{GREETING}} {{NAME}}!" 
    }

    // Variables contain default variables which can be changed from data
    // extracted from the response or from the command line.
    Variables: {
        GREETING: "Hello"
    }
}`,
			Sub: []*Example{
				&Example{
					Name:        "Mock.Dynamic",
					Description: "Dynamic responses based on the request",
					Data: `// Dynamic responses based on the request
{
    Name: "Dynamic response via Data Extractions"
    Description: '''
        Static responses are often too simple and some dependence on the
        incoming request has to be provided. A mock provides three ways to
        extract data from the request:
          1. from the request URL
          2. parsing query form parameters
          3. via explicit data extraction
    '''

    Method: "POST"

    // Variant 1: gorilla mux style path templates:
    URL: "http://localhost:8880/greet/{NAME}"
 
    // Variant 2: parsing query and form parameter
    // A request to http://localhost:8880/greet/Joe?age=12&foo=bar&foo=waz"
    // would extract
    //   NAME=Joe    (from Variant 1)
    //   age=12      (simple query parameter)
    //   foo[0]=bar  (multiple query parameter)
    //   foo[1]=waz 
    // and all POST form data (from application/x-www-form-urlencoded or
    // multipart/form-data POSTS).
    ParseForm: true

    // Variant 3: Explicit data extraction
    // This allows to use the same Extractors as in Tests. See the example
    // Test.Extraction and its sub-examples for additional extractors.
    DataExtraction: {
        SESSION: {Extractor: "CookieExtractor", Name: "sessionid"}
    }
    
    // The response is populated from dynamically values read from variables.
    Response: {
        StatusCode: 200
        Header: {
            "Content-Type": "text/plain"
            "Set-Cookie":   "sessionid={{SESSIONID}}; Max-Age=600"
        }
        Body: '''
           {{GREETING}} {{NAME}}! You are {{age}} years old.
           Your main foo is {{foo[0]}} and your session is {{SESSION}}.
        '''
    }

    // Variables contain default variables which can be changed from data
    // extracted from the response or from the command line.
    Variables: {
        GREETING: "Hello"
        SESSION:  "--unknown--"
    }
}`,
					Sub: []*Example{
						&Example{
							Name:        "Mock.Dynamic.Body",
							Description: "Reading the response body from a file",
							Data: `// Reading the response body from a file
{
    Name: "Body from file"
    Description: '''
       It is possible to read in the body from a file: use the
       "@file:" or "@vfile" syntax as shown below. The difference between
       them is: @file: sends the file as read while @vfile: performs
       variable replacement in the file before sending it as a response.
    '''

    Method: "GET"
    URL: "http://localhost:8880/org/{{CMPNY}}/{{DEPTMNT}}"
    
    Response: {
        StatusCode: 200
        // Depending in the value of CMPNY different files will be used as
        // the response body. Additional variable replacement happens again
        // in the file content.
        Body: "@vfile:mockdata/staff_{{CMPNY}}.csv"
    }
}`,
						}, &Example{
							Name:        "Mock.Dynamic.Complex",
							Description: "Complex table based substitutions",
							Data: `// Complex table based substitutions
{
    Name: "Simulating if/else with tables"
    Description: '''
        Some backend services show a wide range of answers and you would need
        some sort of if/else construct to select the appropriate response
        based on the combination input data.
        This can be simulated by use of a Map table: The last variable's value
        is selected on the combination of the other variables'values. Together
        with wildcards complex answers can be simulated.
    '''

    Method: "GET"
    URL: "http://localhost:8880/data/{{HOUSE}}/{{ROOM}}"
    
    // Map is used to map combinations of several variables to a single result.
    Map: {
        // This map maps tuples of (HOUSE,ROOM) to SIZE
        Variables: ["HOUSE", "ROOM", "SIZE" ]
        
        // Table is the mapping table as a flattened array.
        // Some examples might explain best how this table works:
        //   HOUSE==Ilisos and ROOM=Pantry  --> SIZE=7.5m²
        //   HOUSE==Isthmia and ROOM=Pantry --> SIZE=-??-
        //   HOUSE==Appolo and ROOM=Office  --> SIZE=15m²
        //   HOUSE==Appolo and ROOM=Pantry  --> SIZE=20m²
        // The * works as a wildcard.
        Table: [
            // HOUSE , ROOM     , SIZE
            "Isthmia", "Kitchen", "12m²",
            "Isthmia", "Living" , "19m²",
            "Isthmia", "*"      , "-??-",  // all other rooms in Isthima
            "Ilisos",  "Pantry" , "7.5m²",
            "Ilisos",  "Kitchen", "32m²",
            "Ilisos",  "Office",  "9.7m²",
            "*"     ,  "Office",  "15m²",  // all other offices are 12m²
            "*"     ,  "*",       "20m²",  // default
        ]
    } 

    Response: {
        StatusCode: 200
        Body: "{{SIZE}}"  // Return the room's size here.
    }
}`,
						}, &Example{
							Name:        "Mock.Dynamic.Timestamps",
							Description: "Dynamic timestamps, random IDs and counters",
							Data: `// Dynamic timestamps, random IDs and counters
{
    Name: "Dynamic timestamps"
    Description: '''
        Sometimes one needs the current date/time: There is a data Extractor
        for that: SetTimestamp which allows arbitray formatting and arbitrary
        offsets.
        If you need a random number use the predeclared variable RANDOM.
        A global counter is available as the predeclared variable COUNTER.
        COUNTER is ever increasing but global; don't assume the next value
        will be the current plus one (it could be plus anything).
    '''

    Method: "GET"
    URL: "http://localhost:8880/some/path"
 
    DataExtraction: {
        DATETIME: {Extractor: "SetTimestamp"
                      // Format is a Go packae time layout.
                      Format: "02. Jan. 2006 15:04:05"
                      // The current time can be adjusted through deltas.
                      DeltaMonth: 2, DeltaDay: 5, DeltaT: "96s"
                  }
    }
    
    Response: {
        StatusCode: 200
        Body: '''
           In two months and five days and 96 seconds it is {{DATETIME}}.
           Some random 6 digit number: {{RANDOM}} 
        '''
    }
}`,
						}},
				}},
		}, &Example{
			Name:        "Suite",
			Description: "A generic Suite",
			Data: `// A generic Suite
// Suites are executed via ` + "`" +
				`ht exec <suite>` + "`" +
				`.
{
    Name: "A generic Suite"
    Description: "Explain the Setup, Main, Teardown and Variables fields."
    KeepCookies: true  // Like a browser does, useful for sessions.
    OmitChecks: false  // No, we want the checks to be executed!

    // Setup and Main are the set of Tests executed and considered relevant
    // for this suite's success. The difference is how Tests with failures or
    // error impact suite execution:
    // If any (executed) test in Setup fails, errors (or is bogus) the suite
    // termiantes and none of the following tests from Setup, none from Main
    // and none from Teardown are executed.
    Setup: [
        { File: "Test" }
    ]

    // Main Tests are executed if all Setup Tests pass. In which case all
    // Tests are executed.
    Main: [
        {File: "Test.JSON"}
        {File: "Test.HTML"}
    ]

    // Teardown Tests are executed after Main (i.e. only if all Setup Tests
    // did pass). Their outcome is reported butdo not influence the Suite
    // status: All teardown tests may fail and the Suite still can pass.
    Teardown: [
       {File: "Test.Image"}
    ]

    // Variables provides a set of variables for the individual Tests.
    // variables defined here in the suite overwrite defaults set in the
    // individual Test files. The values here are overwritten byvalues set
    // on the command line.
    Variables: {
       VARNAME: "varvalue"
    }
}`,
			Sub: []*Example{
				&Example{
					Name:        "Suite.InlineTest",
					Description: "Inline Tests in a suite",
					Data: `// Inline Tests in a suite
{
    Name: "Suite with inline tests"
    Main: [
        // Most often a Suite reference a Test stored in a separate file.
        {File: "Test.JSON"}
            
        // But a Test may be included directly into a Suite. (Drawback:
        // such an inline test cannot be reused in a different suite).
        {Test: {
                   Name: "Test of HTML page"
                   Request: { URL: "http://{{HOST}}/html" }
                   Checks: [ {Check: "StatusCode", Expect: 200} ]
               }           
        }
    ]
    // Works the same for Setup and Teardown Tests.
}`,
				}, &Example{
					Name:        "Suite.Variables",
					Description: "Passing variables to Tests, parameterization of Tests",
					Data: `// Passing variables to Tests, parameterization of Tests
{
    Name: "Suite and Variables"

    Main: [
        // Without Variables field: Test.JSON uses it's own defaults if not
        // overwritten from the Suite below if not overwritten from the
        // command line:
        {File: "Test.JSON"}  // FOO == 9876 from below

        // Tests can be called with different values and/or new variables.
        // In this instance of Test.JSON:  FOO==1234 && BAR=="some other value"
        {File: "Test.JSON"
            Variables: {
                FOO: 1234
                BAR: "some other value"
            }
        }
    ]

    Variables: {
        FOO: 9876
    }
}`,
				}},
		}, &Example{
			Name:        "Test",
			Description: "A generic Test",
			Data: `// A generic Test
// Typically Tests are combined into Suites and the suite is executed via
// ` + "`" +
				`ht exec <suite>` + "`" +
				` but you can executes a test via ` + "`" +
				`ht run <test>` + "`" +
				`.
{
    // Name is used during reporting. Make it short and printable.
    Name: "Simple Test"

    Description: '''
        This description is not used but it is nice to
        provide same background information on this test.
    '''

    // Details of the Request follow:
    Request: {
        // The HTTP method. Defaults to GET.
        Method: "GET"    

        // The URL of the request. Can contain query parameter (but these
        // must be properly encoded).
	// Notethe use a variable substitution: {{HOST}} is replaced with the
        // current value of the HOST variable.
        URL:    "http://{{HOST}}/html?q=xyz"
	
	// Header contains the specific http headers to be sent in this request.
	// User-Agent and Accept headers are set automatically to what Chrome
	// sends if not set explicitly.
        Header: {
            Accept-Language: "en,fr"
        }

        // Add URL parameter
        Params: {
            w: "why so?"      // automatic URL-encoding
            u: [123, "abc"]   // can send multiple u
        }

        Timeout: "25s"   // Use longer timeout then the default 10s
        FollowRedirects: true  // Follow redirect chain until non 30x is sent.
    }

    // The list of checks to apply.
    Checks: [
        {Check: "StatusCode", Expect: 200}
        {Check: "ResponseTime", Lower: "700ms"}
    ]

    // Variables provides default values for the variables. The default
    // values can be overwritten from Suites and from the command line.
    Variables: {
        HOST: "www.example.org"
    }
}`,
			Sub: []*Example{
				&Example{
					Name:        "Test.AndOr",
					Description: "Logical AND and NOT of Checks",
					Data: `// Logical AND and NOT of Checks
{
    Name: "Logical conjunctions"
    Description: '''
        Sometimes it is natural to express the desired state as the logical OR
        or the logical NOT of several conditions. Two special Checks allow to
        express this: AnyOne and None.
        (The logical AND is the natural composition of the checks in a Test, so
        there is no extra 'AllOf' check.)
    '''
    Request: { URL: "http://{{HOST}}/json" }
    Checks: [
        // The AnyOne-Of check is the logical of the the given sub checks:
	// Only one of the sub-checks in the Of array must succeed:
        // One out of the three content types makes the AnyOne check pass.
        {Check: "AnyOne", Of: [
            {Check: "ContentType", Is: "application/json"}
            {Check: "ContentType", Is: "application/json5"}
            {Check: "ContentType", Is: "application/jsonp"}
	]}

	// The check None expresses the condition that none of the sub
	// checks may succeed. (This example is rather artificial).
	{Check: "None", Of: [
            {Check: "JSON", Element: "Numbers.0", Equals: "2"}
            {Check: "JSON", Element: "Numbers.1", Equals: "40"}
            {Check: "JSON", Element: "Numbers.3", Equals: "17"}
        ]}
    ]

    // Both AnyOne and None are short cicuiting and evaluate only the
    // sub-checks until the overall result is clear.
}`,
				}, &Example{
					Name:        "Test.Cookies",
					Description: "Testing setting and deleting Cookies in Set-Cookie headers",
					Data: `// Testing setting and deleting Cookies in Set-Cookie headers
{
    Name: "Test SeCookie Headers"
    Request: {
        URL: "http://{{HOST}}/other"
        Timeout: 2s
    }
    Checks: [
        {Check: "StatusCode", Expect: 200}

	// Cookie cip was set to any value with any properties:
        {Check: "SetCookie", Name: "cip"}

	// Make sure cip's path is /
        {Check: "SetCookie", Name: "cip", Path: {Equals: "/"}}

        // Value is 20 to 32 alphanumeric characters
        {Check: "SetCookie", Name: "cip", Value: {Regexp: "[[:alnum:]]{20,32}"}}

	// cip is persistent (not a session cookie) with a lifetime of at
	// least 10 minutes and Http-Only
        {Check: "SetCookie", Name: "cip", MinLifetime: "10m"
            Type: "persistent httpOnly"}

        // Make sure cookie tzu gets deleted properly
        {Check: "DeleteCookie", Name: "tzu"}
    ]
}`,
				}, &Example{
					Name:        "Test.CurrentTime",
					Description: "Working with current time or date",
					Data: `// Working with current time or date
{
    Name: "Current time and date"
    Description: '''
        Unfortunately it is not straight forward to include the current date
        or time in a Test. But this can be simulated with Variables:
        You can always inject e.g. the current date via the command line
        as the value of a variable.
        The solution here might be a bit more flexible: The SetTimestamp
        data extractor can "extract" the current date/time (with arbitrary
        offset) into a variable. The value of this variable can be used
        in subsequent tests as the current date/time or some date/time
        in the future or past with defined offset to now.
        The Format string is the reference time Go's time package.
    '''

    // A dummy request: We are interested in the current date/time only.
    Request: { URL: "http://{{HOST}}/html" }

    DataExtraction: {
        // Store the current date and time in NOW
        NOW: {Extractor: "SetTimestamp", Format: "2006-01-02 15:04:05" }

	// Store date of the day after tomorrow in FUTURE
        FUTURE: {Extractor: "SetTimestamp", DeltaDay: 2, Format: "2006-01-02" }
    }
}`,
				}, &Example{
					Name:        "Test.Extraction",
					Description: "Extracting data from a Response",
					Data: `// Extracting data from a Response
{
    Name: "Data Extraction"

    Description: '''
        Combining tests into larger suites is useful only if later requests
        can depend on the result of earlier requests. This is like this in ht:
          1. Extract some data from a response and store it in a variable
          2. Use that variable in subsequent requests/tests
        This examples shows the generic mechanism of step 1.
    '''

    Request: { URL: "http://{{HOST}}/html" }
    Checks: [
        {Check: "StatusCode", Expect: 200}

        // Data extraction does not influence the test state: If the given
        // value could not be extracted the test is still in state Pass.
        // If subsequent tests/request rely on a proper data extraction: Add a
        // check like the following to make sure the test fails if no suitable
        // value is present
        {Check: "Body", Regexp: "It's ([0-9:]+) o'clock"}
    ]

    // Define how variable values should be extracted from the response   
    DataExtraction: {
        // Set the value of SOME_VARIABLE. Use a generic "BodyExtractor"
        // to extract a value from the response body via a regular expression.
        SOME_VARIABLE: {
            Extractor: "BodyExtractor"

            // The regular expression to extract. This one would match e.g.
            // It's 12:45 o'clock.
            Regexp: "It's ([0-9:]+) o'clock"

            // Do not use the full match but only the first submatch which
            // will be the numerical time (here "12:45")
            Submatch: 1  
        }

        // Extract the session from the Set-Cookie handler.
        SESSION_ID: { Extractor: "CookieExtractor", Name: "SessionID" }
    }

    // Note that Data extraction happens only for Pass'ed test.
}`,
					Sub: []*Example{
						&Example{
							Name:        "Test.Extraction.HTML",
							Description: "Extracting data from HTML documents, e.g. hidden form values",
							Data: `// Extracting data from HTML documents, e.g. hidden form values
{
    Name: "Data extraction from HTML"
    Request: { URL: "http://{{HOST}}/html" }
    /* HTML has the following content:
           <h1>Sample HTML</h1>
           <form id="mainform">
             <input type="hidden" name="formkey" value="secret" />
           </form>
    */
    Checks: [
        {Check: "StatusCode", Expect: 200}
    ]

    DataExtraction: {
        FORM_KEY: {
            Extractor: "HTMLExtractor"
            // CSS selector of tag to extract data from
            Selector: "#mainform input[name=\"formkey\"]"
            Attribute: "value" // Extract content of this attribute.
        }
        TITLE: {
            Extractor: "HTMLExtractor"
            Selector: "h1"
            // Do not extract data from attribute but the text content
            // from the h1 tag
            Attribute: "~text~"
        }
    }

}`,
						}, &Example{
							Name:        "Test.Extraction.JSON",
							Description: "Extracting data from a JSON document",
							Data: `// Extracting data from a JSON document
{
    Name: "Data Extraction from JSON"

    Request: { URL: "http://{{HOST}}/json" }
    /* The returned JSON looks like this:
         {
            "Date": "2017-09-20",
            "Numbers": [6, 25, 26, 27, 31, 38],
            "Finished": true,
         }
    */     
    Checks: [
        {Check: "StatusCode", Expect: 200}
        // The following checks make sure that the tests fails if the
        // extraction woudn't succeed.
        {Check: "JSON", Element: "Date", Prefix: "\"", Suffix: "\"" }
        {Check: "JSON", Element: "Finished", Regexp: "true|false" }
        {Check: "JSON", Element: "Numbers.3", Is: "Int" }
    ]

    DataExtraction: {
        DATE:     {Extractor: "JSONExtractor", Element: "Date" }  // 2017-09-20
        FINISHED: {Extractor: "JSONExtractor", Element: "Finished" }   // true
        THIRDNUM: {Extractor: "JSONExtractor", Element: "Numbers.3" }  // 27
    }
}`,
						}},
				}, &Example{
					Name:        "Test.FollowRedirect",
					Description: "Automatic follow of redirects and suitable tests ",
					Data: `// Automatic follow of redirects and suitable tests 
{
    Name: "Follow Redirections"
    Request: {
        URL: "http://{{HOST}}/redirect2"
        FollowRedirects: true
    }
    Checks: [
        // FollowRedirects follows redirects until 200 is received.
        {Check: "StatusCode", Expect: 200}

        // Check intermediate locations.
        {Check: "RedirectChain"
            Via: [ ".../redirect1", ".../html" ]
        }

	// Apply condition to final URL. Here full equality.
        {Check: "FinalURL", Equals: "http://{{HOST}}/html"}
    ]
}`,
				}, &Example{
					Name:        "Test.HTML",
					Description: "Testing HTML documents",
					Data: `// Testing HTML documents
{
    Name: "Test of HTML page"
    Request: {
        URL: "http://{{HOST}}/html"
        Timeout: 2s
    }
    Checks: [
        {Check: "StatusCode", Expect: 200}
        {Check: "ResponseTime", Lower: "700ms"}
        {Check: "ContentType", Is: "text/html"}
        {Check: "UTF8Encoded"}
        {Check: "ValidHTML"}

        // Uncomment if it's okay to send response to W3C Validator. 
        // {Check: "W3CValidHTML", AllowedErrors: 5}  

        // Make sure resources linked from the HTML document are accessable.
        {Check: "Links"
            Which: "a link img script"  // check only these tags
            Head: true                  // HEAD request is enough
            Concurrency: 8              // check 8 links in parallel
            IgnoredLinks: [
                // No need to check these links
                {Contains: "facebook.com"},
                {Equals: "http://www.twitter.com/foo/bar"}
            ]
            FailMixedContent: true
        }
    ]
}`,
				}, &Example{
					Name:        "Test.Header",
					Description: "Testing HTTP response headers",
					Data: `// Testing HTTP response headers
{
    Name: "Test of HTTP response header"
    Request: { URL: "http://{{HOST}}/xml" }
    Checks: [
        {Check: "StatusCode", Expect: 200}

	// Check presence of Content-Type header, value is ignored.
        {Check: "Header", Header: "Content-Type"}

	// Check Value of X-Licence header: Must start withd "BSD"
        {Check: "Header", Header: "X-Licence", Prefix: "BSD"}
    ]
}`,
				}, &Example{
					Name:        "Test.Image",
					Description: "Testing images",
					Data: `// Testing images
{
    Name: "Test of a PNG image"
    Description: '''
        The Image check allows to check the file format and the size of an
        image. It also knows about block mean value and color histogram
        fingerprints for images which are nsensitive against some image
        transformations and can be computed via the fingerprint subcommand.
        If you whant to ensure that exacty a certain file is served you
        should use the Identity check.
    '''
    Request: {
        URL: "http://{{HOST}}/lena"
    }
    Checks: [
        {Check: "StatusCode", Expect: 200}
        {Check: "Image"}  // response is an image
        {Check: "Image", Format: "png"}  // it's a PNG image
        {Check: "Image", Width: 20, Height: 20}  // proper size

	// Check color fingerprint of image.
        {Check: "Image", Fingerprint: "-P000000Zn0000l0100a030a", Threshold: 0.0025}

	// Check block-mean-value (BMV) fingerprint of image
        {Check: "Image", Fingerprint: "be1cbd8d0b0b0f8c"}

        // Combined
        {Check: "Image", Fingerprint: "be1cbd8d0b0b0f8c", Width: 20, Height: 20, Format: "png"}

        // Check full binary identity:
        {Check: "Identity", SHA1: "f2534d702f0b18907162d7017357608ab2a40e2b"}
    ]
}`,
				}, &Example{
					Name:        "Test.JSON",
					Description: "Testing JSON documents",
					Data: `// Testing JSON documents
{
    Name: "Test of a JSON document"
    Request: {
        URL: "http://{{HOST}}/json"
    }
    Checks: [
        {Check: "StatusCode", Expect: 200}
        {Check: "UTF8Encoded"}
        {Check: "ContentType", Is: "application/json"}

        // Valid JSON, don't care about anything else.
        {Check: "JSON"}

        // Presence of field "Date", any value of any type is okay.
        {Check: "JSON", Element: "Date"}

        // Check value of Date fields. Pay attention to quotes of strings.
        {Check: "JSON", Element: "Date", Equals: "\"2017-09-20\""}
        {Check: "JSON", Element: "Date", Contains: "2017-09-20"}
        {Check: "JSON", Element: "Finished", Equals: "true"}

        // Access to deeply nested elements.
        {Check: "JSON", Element: "Numbers.0", Equals: "6"}
        {Check: "JSON", Element: "Numbers.1", GreaterThan: 6, LessThan: 45}
        // Change field seperator if your field names contain the default "."
        {Check: "JSON", Sep: "_@_",  Element: "a.b_@_wuz_@_1", Equals: "9"}

        // Check structure of JSON and type of data with Schema.
        {Check: "JSON", Schema: '''
            {
               "Date":     "",
               "Numbers":  [0,0,0,0,0,0],
               "Finished": false,
               "Raw":      "",
               "a.b":      { "wuz": [] }
            }'''
        }

        // Interpret and check strings which contain embedded JSON:
        {Check: "JSON", Element: "Raw", Embedded: {Element: "coord.1", Equals: "-1"}}
        {Check: "JSON", Element: "Raw", Embedded: {Element: "label", Equals: "\"X\""}}

        // There's a different check for JSON: JSONExpr
        {Check: "JSONExpr", Expression: "$len(.Numbers) > 4"}
        {Check: "JSONExpr", Expression: "$max(.Numbers) == 38"}
    ]
}`,
				}, &Example{
					Name:        "Test.Mixin",
					Description: "A Test including Mixins",
					Data: `// A Test including Mixins
{
    Name: "Test with Mixins"
    Mixin: [
        "Mixin"
        "Mixin.Checks"
    ]
    Description: "Most parts of this Test com from the two Mixins above." 
    Request: {
        URL:    "http://{{HOST}}/html"
        // Additional Request fields are loaded from Mixin
    }
    Checks: [
        {Check: "Body", Contains: "e"}
        // Additional Checks are loaded from Mixin.Checks
    ] 
}`,
				}, &Example{
					Name:        "Test.NoneHTTP",
					Description: "Reading files, querying databases and executing bash scripts",
					Data: `// Reading files, querying databases and executing bash scripts
{
    Name: "Pseudo-requests"

    Description: '''
        A normal Test makes a HTTP request but ht also allows to query a
        database, read a file or execute a bash script and perform checks
        on their output. Such 'pseudo-requests' are triggered via special
        schemas in the Request.URL:

          file://  allows to read, write and delete files
          bash://  allows to execute a bash script
          sql://   allows to execute SQL statements against a database

        This example here is a stub, please consult the sub topics.
    '''

    Request: {
        // The 'file://' schema makes this a File pseudo-request.
        URL: "file://localhost/etc/passwd"
    }

    Checks: [
        {Check: "Body", Contains: ":root:"}  // to be expected in /etc/passwd
    ]
}`,
					Sub: []*Example{
						&Example{
							Name:        "Test.NoneHTTP.Bash",
							Description: "Reading files, querying databases and executing bash scripts",
							Data: `// Reading files, querying databases and executing bash scripts
{
    Name: "Pseudo-requests"

    Description: '''
        A normal Test makes a HTTP request but ht also allows to query a
        database, read a file or execute a bash script and perform checks
        on their output. Such 'pseudo-requests' are triggered via special
        schemas in the Request.URL:

          file://  allows to read, write and delete files
          bash://  allows to execute a bash script
          sql://   allows to execute SQL statements against a database

        This example test here describes executing a bash script.
    '''

    Request: {
        // The 'bash://' schema makes this a Bash-pseudo-request.
        // Bash scripts can be executed only on the same machine (localhost).
        // The Working Directory in which the script is executed is the path
        // of the URL. So you cannot use relative paths.
        URL:    "bash://localhost/{{CWD}}/{{TEST_DIR}}"

        // The request params are used as environment in which the script
        // executes: Inside the script the bash variables ENVVAR1 and ENVVAR2
        // will be set with the given values.
        Params: {
            ENVVAR1: "some value"
            ENVVAR2: "12345"
        }

        // The script's running time is limited to Timeout
	Timeout: "25s"

        // The body contains the bash script. This is just an example.
        // The body could be read from a file with the @[v]file-syntax:
        //     Body: "@vfile:{{TEST_DIR}}/script.bash"
        // For this simple example we provide it directly.
        Body: '''
            # Run the ls command in long form
	    ls -l 
        '''

        // All other fields of Request are ignored for bash pseudo-requests.
    }

    Checks: [
        // Bash pseudo-request report in the  HTTP status code:
        //    - 200 if the script's exit code is 0.
        //    - 408 if the script was canceled due to timeout
        //    - 500 if the exit code is != 0.
        {Check: "StatusCode", Expect: 200}

        // The numerical exits status itself is reported in the response
        // header Exit-Status:
        {Check: "Header", Header: "Exit-Status", Equals: "exit status 0"}

        // The combined output (stdout and stderr) of the script is returned
        // as the response body:
        {Check: "Body", Contains: "Suite.Variables"}
    ]
}`,
						}, &Example{
							Name:        "Test.NoneHTTP.FileDelete",
							Description: "Deleting files",
							Data: `// Deleting files
{
    Name: "Deleting Files"

    Request: {
        Method: "DELETE"  // DELETE request delete files.

        // The 'file://' schema makes this a File pseudo-request.
        // The path of the URL is the path path of the file.
        URL: "file://localhost/tmp/somefile"

        // All other fields of Request are ignored.
    }

    Checks: [
        // File pseudo-request report in the  HTTP status code:
        //    - 200 if the file was deleted
        //    - 403 if it was not deleted
        //    - 404 if there was no such file in the first place
        {Check: "StatusCode", Expect: 200}
    ]
}`,
						}, &Example{
							Name:        "Test.NoneHTTP.FileRead",
							Description: "Reading files",
							Data: `// Reading files
{
    Name: "Reading Files"

    Request: {
        Method: "GET"  // GET reads the files

        // The 'file://' schema makes this a File pseudo-request.
        // The path of the URL is the path path of the file.
        // Here we are reading the current file.
        // Note that absolute paths have to be used (as relative
        // paths cannot be encoded in the URL.
        URL: "file://localhost/{{CWD}}/{{TEST_DIR}}/Test.NoneHTTP.FileRead"

        // All other fields of Request are ignored.
    }

    Checks: [
        // File pseudo-request report in the  HTTP status code:
        //    - 200 if the file was readable
        //    - 404 otherwise
        {Check: "StatusCode", Expect: 200}

        // The file content is returned as the response body:
        {Check: "Body", Prefix: "// Reading files", Suffix: "} // eof"}
    ]
} // eof`,
						}, &Example{
							Name:        "Test.NoneHTTP.FileWrite",
							Description: "Writing files",
							Data: `// Writing files
{
    Name: "Writing Files"

    Request: {
        Method: "PUT"  // PUT request write files

        // The 'file://' schema makes this a File pseudo-request.
        // The path of the URL is the path path of the file.
        URL: "file://localhost/tmp/somefile"

        Body: '''
            The request body is written to the file.
            Nothing more to see here.
        '''

        // All other fields of Request are ignored.
    }

    Checks: [
        // File pseudo-request report in the  HTTP status code:
        //    - 200 if the file was written
        //    - 404 otherwise
        {Check: "StatusCode", Expect: 200}
    ]
}`,
						}, &Example{
							Name:        "Test.NoneHTTP.SQLExec",
							Description: "Querying a MySQL database",
							Data: `// Querying a MySQL database
{
    Name: "SQL Execute"

    Request: {
        // POST executes SQL statements like CREATE or INSERT.
        // For SELECT queries use GET.
        Method: "POST"

        // The 'sql://' schema makes this a SQL pseudo-request.
        // The host of the URL select the database driver.
	// Currently only mysql is "supported"
        URL: "sql://mysql"

        Header: {
            // Mandatory: The data source name is for the data base driver
            // is passed in this header field
            "Data-Source-Name": "test:test@tcp(127.0.0.1:7799)/test?multiStatements=true"
        }

        // The Body contains the SQL Query
        Body: '''
            DROP TABLE IF EXISTS orders;
            CREATE TABLE orders (
               id INT NOT NULL AUTO_INCREMENT UNIQUE PRIMARY KEY,
               product VARCHAR(30),
               price DECIMAL(4,2)
             );
             INSERT INTO orders
               (product,price)
             VALUES
               ("Badetuch", 17.10),
               ("Taschenmesser", 24.00),
               ("Puzzle", 9.70)
             ;

        '''

        // All other fields of Request are ignored.
    }

    // The result of a SQL pseudo-request POST is always a JSON document.
    // It has the following form:
    //   {
    //      "LastInsertId": {"Value": 1234, "Error": "message"},
    //      "RowsAffected": {"Value": 0,    "Error": "something went wrong"}
    //   }
    Checks: [
        {Check: "JSON"}
        {Check: "JSON", Element: "LastInsertId.Value", Is: "Int"}
    ]

    // Extract the last insert id into a variable for use in subsequent tests.
    DataExtraction: {
        LAST_ID: {Extractor: "JSONExtractor", Element: "LastInsertId.Value" }
    }
}`,
						}, &Example{
							Name:        "Test.NoneHTTP.SQLQuery",
							Description: "Querying a MySQL database",
							Data: `// Querying a MySQL database
{
    Name: "SQL Queries"

    Request: {
        Method: "GET"  //  GET performs a SQL Query (SELECT FROM WHERE)

        // The 'sql://' schema makes this a SQL pseudo-request.
        // The host of the URL select the database driver.
	// Currently only mysql is "supported"
        URL: "sql://mysql"

        Header: {
            // Mandatory: The data source name is for the data base driver
            // is passed in this header field
            "Data-Source-Name": "test:test@tcp(127.0.0.1:7799)/test"

            // The format of the response body is determined by the
	    // Accept header:
            //   - "application/json"
            //     JSON array with the rows as objects with the table columns
            //     as fields
            //   - "text/csv; header=present"
            //     Csv file with column headers (the column names)
            //   - "text/csv"
            //     Csv file without header, just the data
            //   - "text/plain"
            //     Plain text file columns separated by "\t"
            //   - "text/plain; fieldsep=X"
            //     Plain text file columns separated by "X"
            "Accept": "text/csv; header=present"

        }

        // The Body contains the SQL Query
        Body: '''
            SELECT id AS orderID, product, price
            FROM orders
            ORDER BY price DESC;
        '''

        // All other fields of Request are ignored.
    }

    Checks: [
        {Check: "Body", Prefix: "orderID,product,price"}
        {Check: "Body", Contains:"2,Taschenmesser,24.00" }
    ]
}`,
						}},
				}, &Example{
					Name:        "Test.POST",
					Description: "Generating POST requests",
					Data: `// Generating POST requests
{
    Name: "Test a POST request"
    Request: {
        Method:   "POST"
        URL:      "http://{{HOST}}/post"
        ParamsAs: "body"   // send as application/x-www-form-urlencoded in body
        Params: {
            "action":      "update"  // simple
            "data[1][7]":  12        // fancy parameter name
            "what":        "automatic encoding+escaping!" // let ht do the hard stuff
            "several": [ "foo", "bar", 123 ]  // multiple values
        }
    }
    Checks: [
        {Check: "StatusCode", Expect: 200}
    ]
}`,
					Sub: []*Example{
						&Example{
							Name:        "Test.POST.BodyFromFile",
							Description: "Reading a POST body from a file",
							Data: `// Reading a POST body from a file
{
    Name: "Test body read from file"
    Request: {
        Method:  "POST"
        URL:     "http://{{HOST}}/post"
	Header:  { "Content-Type": "application/json" }

        // Body can use @file and @vfile just like Params:
        // The @vfile version will perform variable substitution in the
        // content of somefile. Note how somefile is read relative to
        // directory of this test-file.
        Body: "@vfile:{{TEST_DIR}}/somefile"

        // Use the @file form if no variable substitution inside somefile
	// shell be performed.	
        // Body: "@file:{{TEST_DIR}}/somefile"
    }

    Checks: [
        {Check: "StatusCode", Expect: 200}
        {Check: "Body", Contains: "TheFoo"}
    ]

    Variables: { FOO: "TheFoo" }
}`,
						}, &Example{
							Name:        "Test.POST.FileUpload",
							Description: "Uploading files as multipart data",
							Data: `// Uploading files as multipart data
{
    Name: "Test file uploads"
    Request: {
        Method:   "POST"
        URL:      "http://{{HOST}}/post"
        ParamsAs: "multipart"   // send as multipart/form-data
        Params: {
            // action is a simple parameter
            "action":  "update"
 
            // upload exact content of Test.HTML from current folder as file1
            "file1":  "@file:{{TEST_DIR}}/somefile"

            // substitute variables in Test.HTML before uploading
            "file2":  "@vfile:{{TEST_DIR}}/somefile"
        }
    }

    Checks: [
        {Check: "StatusCode", Expect: 200}
    ]

    Variables: { FOO: "TheFoo" }
}`,
						}, &Example{
							Name:        "Test.POST.ManualBody",
							Description: "Manually defining a POST body.",
							Data: `// Manually defining a POST body.
{
    Name: "Test POST body"
    Request: {
        Method:  "POST"
        URL:     "http://{{HOST}}/post"
	Header:  { "Content-Type": "application/json" }

	// Manualy crafted request body. 
        Body: '''  {"status": "success"}  '''

        // Body can use @file and @vfile just like Params:
        // The @vfile version will perform variable substitution in the
        // content of somefile. Note how somefile is read relative to
        // directory of this test-file.
        // Body: "@vfile:{{TEST_DIR}}/somefile"

        // Use the @file form if no variable substitution inside somefile
	// shell be performed.	
        // Body: "@file:{{TEST_DIR}}/somefile"
    }
    Checks: [
        {Check: "StatusCode", Expect: 200}
        {Check: "Body", Contains: "success"}
    ]
}`,
						}},
				}, &Example{
					Name:        "Test.Redirection",
					Description: "Testing redirect responses",
					Data: `// Testing redirect responses
{
    Name: "Redirections"
    Request: {
        URL: "http://{{HOST}}/redirect1"
    }
    Checks: [
        {Check: "StatusCode", Expect: 301}
        {Check: "Redirect", To: ".../html"}
        {Check: "Redirect", To: ".../html", StatusCode: 301}
    ]
}`,
				}, &Example{
					Name:        "Test.Retry",
					Description: "Retrying failed tests and polling services.",
					Data: `// Retrying failed tests and polling services.
{
    Name: "Retry a test several times"
    
    Request: { URL: "http://{{HOST}}/html" }
    Checks: [ {Check: "StatusCode", Expect: 200} ]

    // Execution controls timing and retrying of a test
    Execution: {
        // Try this test up to 7 times. If all 7 tries fail report a failure.
        // Report pass after the first passing run.
        Tries: 7
        Wait: "800ms"   // Wait 0.8 seconds between retries.
    }
    // Retrying a test can also be used to poll a service-endpoint which takes
    // some time to provide information: Instead of sleeping 60 seconds before
    // querying the service poll it every 5 seconds for up to 15 tries.
}`,
				}, &Example{
					Name:        "Test.Speed",
					Description: "Testing the response speed of an application",
					Data: `// Testing the response speed of an application
{
    Name: "Test response time and latency"
    Request: {
        URL: "http://{{HOST}}/html"
        Timeout: 2s
    }
    Checks: [
        {Check: "StatusCode", Expect: 200}

	// Response time of request from above
        {Check: "ResponseTime", Lower: "100ms", Higher: "35ns"}
        
	// Make 200 extra request to the same URL, 4 in parallel.
        {Check: "Latency", N: 200, Concurrent: 4, SkipChecks: true,
            // Check percentiles of response time
            Limits: "50% ≤ 100ms; 80% ≤ 150ms; 95% ≤ 200ms; 0.995 ≤ 0.75s"
        }

	// Dump data 
        {Check: "Latency", N: 40, Concurrent: 4, SkipChecks: true,
            DumpTo: "stdout",
            Limits: "50% ≤ 100ms; 80% ≤ 150ms; 95% ≤ 200ms; 0.995 ≤ 0.75s"
        }


    ]
}`,
				}, &Example{
					Name:        "Test.XML",
					Description: "Testing XML documents",
					Data: `// Testing XML documents
{
    Name: "Test of a XML document"
    Request: {
        URL: "http://{{HOST}}/xml"
    }
    Checks: [
        {Check: "StatusCode", Expect: 200}
        {Check: "UTF8Encoded"}
        {Check: "ContentType", Is: "application/xml"}

        // Presence of element, no condition imposed on value.
        {Check: "XML", Path: "/library/book/character[2]/name" },

        // Check existence and value.
        {Check: "XML"
            Path: "/library/book/character[2]/name"
            Equals: "Snoopy"
         }

        // Check several Conditions on the value:
        {Check: "XML"
            Path: "//book[author/@id='CMS']/title"
            Prefix: "Being"
            Contains: "Dog"
         }
    ]
}`,
				}},
		}},
}
