package imgcmp

import (
	"fmt"
	"image"
	"os"
	"strings"
	"testing"
)

var _ = fmt.Printf

func readImage(fn string) image.Image {
	file, err := os.Open(fn)
	if err != nil {
		if _, pe := err.(*os.PathError); pe {
			panic("Cannot read file " + fn + ". Did you create the test data with 'make all'?")
		} else {
			panic(err)
		}
	}
	defer file.Close()

	// Decode the image.
	img, _, err := image.Decode(file)
	if err != nil {
		panic(err)
	}
	return img
}

func BMVHashFromFile(fn string) BMVHash {
	fn = "testdata/" + fn
	h := NewBMVHash(readImage(fn))
	return h
}

func TestHammingDistance(t *testing.T) {
	a := BMVHash(0x99) // 10011001
	b := BMVHash(0x9a) // 10011010
	c := BMVHash(0x9b) // 10011011
	d := BMVHash(0x33) // 00110011

	if a.HammingDistance(a) != 0 {
		t.Fail()
	}
	if a.HammingDistance(b) != 2 {
		t.Fail()
	}
	if a.HammingDistance(c) != 1 {
		t.Fail()
	}
	if a.HammingDistance(d) != 4 {
		t.Fail()
	}
	if c.HammingDistance(d) != 3 {
		t.Fail()
	}
}

func TestBitBlock(t *testing.T) {
	h := BMVHash(0xff00aa0f55f03cc3)
	b := strings.Join(h.BitBlock(), "|")
	if b != "11111111|00000000|10101010|00001111|01010101|11110000|00111100|11000011" {
		t.Errorf("Got %s", b)
	}
}

func singleCmp(t *testing.T, car, size, dist string) {
	origname := car + size + ".jpg"
	orig := BMVHashFromFile(origname)
	// fmt.Printf("File %20s: %s\n", origname, orig.String())
	dname := car + size + dist + ".jpg"
	d := BMVHashFromFile(dname)
	// fmt.Printf("File %20s: %s\n", dname, d.String())
	if orig != d && orig.HammingDistance(d) > 1 {
		if dname == "car1-s_sm.jpg" && orig.HammingDistance(d) == 2 {
			return // that's fine
		}
		t.Errorf("Difference %s: %s, %s: %s, HD=%d\n%s",
			origname, orig.String(), dname, d.String(),
			orig.HammingDistance(d), orig.Delta(d))
	}
}

func TestSingle(t *testing.T) {
	singleCmp(t, "car1", "-t", "_lg")
}

func TestBMB(t *testing.T) {
	count := 0
	for _, car := range []string{"car1", "car2", "car3", "car4"} {
		for _, size := range []string{"-t", "-s", "-m", "-l"} {
			for _, dist := range []string{"_lq", "_lg", "_sm"} {
				singleCmp(t, car, size, dist)
				count++
			}
		}
	}
	t.Log("Calculated", count, " block mean value hashes")
}

func BenchmarkBMVHash(b *testing.B) {
	img := readImage("testdata/car1-o.jpg")
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		NewBMVHash(img)
	}
}
